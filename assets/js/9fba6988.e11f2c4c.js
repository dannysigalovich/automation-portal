"use strict";(self.webpackChunkautomation_dev_portal=self.webpackChunkautomation_dev_portal||[]).push([[890],{3379:(e,r,s)=>{s.r(r),s.d(r,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>a,metadata:()=>o,toc:()=>d});var t=s(4848),n=s(8453);const a={sidebar_position:1},i="Adapter",o={id:"Guides/programming/design-patterns/adapter",title:"Adapter",description:"Adapter Design Pattern:",source:"@site/docs/Guides/programming/design-patterns/adapter.md",sourceDirName:"Guides/programming/design-patterns",slug:"/Guides/programming/design-patterns/adapter",permalink:"/automation-portal/docs/Guides/programming/design-patterns/adapter",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Design Patterns",permalink:"/automation-portal/docs/category/design-patterns"},next:{title:"Builder",permalink:"/automation-portal/docs/Guides/programming/design-patterns/builder"}},l={},d=[{value:"<strong>Adapter Design Pattern:</strong>",id:"adapter-design-pattern",level:2}];function p(e){const r={code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,n.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.h1,{id:"adapter",children:"Adapter"}),"\n",(0,t.jsx)(r.h2,{id:"adapter-design-pattern",children:(0,t.jsx)(r.strong,{children:"Adapter Design Pattern:"})}),"\n",(0,t.jsxs)(r.p,{children:["Adapters allow incompatible objects to be used together. Following the Open-Closed principle, we can extend class behaviour without modifying the class itself. If a ",(0,t.jsx)(r.strong,{children:"MicroUsbCable"})," class is initially incompatible with ",(0,t.jsx)(r.strong,{children:"UsbPort"}),", we can create a wrapper class (i.e. an Adapter), which makes them compatible. In this case, a ",(0,t.jsx)(r.strong,{children:"MicroToUsbAdapter"})," makes them compatible, similar to how we use adapters in the real-world."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-python",children:"class UsbCable:\r\n    def __init__(self):\r\n        self.isPlugged = False\r\n    \r\n    def plugUsb(self):\r\n        self.isPlugged = True\r\n\r\nclass UsbPort:\r\n    def __init__(self):\r\n        self.portAvailable = True\r\n    \r\n    def plug(self, usb):\r\n        if self.portAvailable:\r\n            usb.plugUsb()\r\n            self.portAvailable = False\r\n\r\n# UsbCables can plug directly into Usb ports\r\nusbCable = UsbCable()\r\nusbPort1 = UsbPort()\r\nusbPort1.plug(usbCable)\r\n\r\nclass MicroUsbCable:\r\n    def __init__(self):\r\n        self.isPlugged = False\r\n    \r\n    def plugMicroUsb(self):\r\n        self.isPlugged = True\r\n\r\nclass MicroToUsbAdapter(UsbCable):\r\n    def __init__(self, microUsbCable):\r\n        self.microUsbCable = microUsbCable\r\n        self.microUsbCable.plugMicroUsb()\r\n\r\n    # can override UsbCable.plugUsb() if needed\r\n\r\n# MicroUsbCables can plug into Usb ports via an adapter\r\nmicroToUsbAdapter = MicroToUsbAdapter(MicroUsbCable())\r\nusbPort2 = UsbPort()\r\nusbPort2.plug(microToUsbAdapter)\n"})})]})}function c(e={}){const{wrapper:r}={...(0,n.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}},8453:(e,r,s)=>{s.d(r,{R:()=>i,x:()=>o});var t=s(6540);const n={},a=t.createContext(n);function i(e){const r=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),t.createElement(a.Provider,{value:r},e.children)}}}]);